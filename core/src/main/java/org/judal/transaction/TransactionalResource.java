package org.judal.transaction;

/*
 * Â© Copyright 2016 the original author.
 * This file is licensed under the Apache License version 2.0.
 * You may not use this file except in compliance with the license.
 * You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.
 */

import java.util.*;
import java.util.Map.Entry;

import static javax.transaction.Status.*;
import javax.transaction.xa.XAException;
import javax.transaction.xa.XAResource;
import javax.transaction.xa.Xid;

/**
 * <p>Abstract base of javax.transaction.xa.XAResource interface.</p>
 * @author Sergio Montoro Ten
 * @version 1.0
 */
public abstract class TransactionalResource implements XAResource {

	private Xid trid;
	private int timeout;
	private boolean prepared;

	private static TransactionalResourcesMap resources = new TransactionalResourcesMap();

	/**
	 * <p>Constructor.</p>
	 * Create a new TransactionalResource using an autogenerated javax.transaction.xa.Xid
	 */
	public TransactionalResource() {
		this(new TransactionId());
	}

	/**
	 * <p>Constructor.</p>
	 * Create a new TransactionalResource using the given javax.transaction.xa.Xid
	 * @param tid Xid
	 */
	public TransactionalResource(Xid tid) {
		trid = tid;
		prepared = false;
		timeout = -1;
		LinkedList<TransactionalResource> list;
		if (resources.containsKey(tid)) {
			list = resources.get(tid);
			list.add(this);
		} else {
			list = new LinkedList<>();
			list.add(this);
			resources.put(tid, list);
		}
	}
	
	protected abstract void startResource(int flags) throws XAException;
	
	protected abstract int prepareResource() throws XAException;

	protected abstract void commitResource() throws XAException;

	protected abstract void rollbackResource() throws XAException;
	
	protected abstract void endResource(int flag) throws XAException;

	public abstract boolean setTransactionTimeout(int seconds);
	
	/**
	 * @return Xid
	 */
	public Xid getId() {
		return trid;
	}

	/**
	 * <p>List resources participating in a transaction.</p>
	 * @param tid Xid Transaction id
	 * @return Unmodifiable List&lt;TransactionalResource&gt;
	 * @throws XAException
	 */
	public List<TransactionalResource> listResourcesForTransaction(Xid tid) throws XAException {
		if (!resources.containsKey(tid))
			resources.put(tid, new LinkedList<TransactionalResource>());
		return Collections.unmodifiableList(resources.get(tid));
	}

	/**
	 * @param tid Xid
	 * @param onePhase boolean
	 * @throws XAException
	 */
	@Override
	public void commit(Xid tid, boolean onePhase) throws XAException {
		commitResource();
		prepared = false;
	}

	/**
	 * @param tid Xid
	 * @param onePhase boolean
	 * @throws XAException
	 */
	@Override
	public void end(Xid tid, int onePhase) throws XAException {
		endResource(onePhase);
		prepared = false;
		if (resources.containsKey(tid))
			resources.get(tid).remove(this);
	}

	/**
	 * @param tid Xid
	 * @throws XAException
	 */
	@Override
	public void forget(Xid tid) throws XAException {
		if (resources.containsKey(tid))
			resources.get(tid).remove(this);
	}

	/**
	 * @return int
	 * @throws XAException
	 */
	@Override
	public int getTransactionTimeout() throws XAException {
		return timeout;
	}

	/**
	 * @param res XAResource
	 * @return boolean <b>true</b> if res is instance of TransactionalResource
	 * @throws XAException
	 */
	@Override
	public boolean isSameRM(XAResource res) throws XAException {
		return res instanceof TransactionalResource;
	}

	/**
	 * <p>Prepare resource.</p>
	 * @param tid Xid
	 * @throws XAException
	 * @return int XA_OK
	 */
	@Override
	public int prepare(Xid tid) throws XAException {
		prepareResource();
		return XA_OK;
	}

	@Override
	public Xid[] recover(int flag) throws XAException {
		ArrayList<Xid> list = new ArrayList<Xid>();
		for (Entry<Xid,LinkedList<TransactionalResource>> branch : resources.entrySet()) {
			if (branch.getValue().peekFirst().prepared)
				list.add(branch.getKey());
		}
		return list.toArray(new Xid[list.size()]);
	}

	/**
	 * <p>Rollback resource.</p>
	 * @param tid Xid
	 * @throws XAException
	 */
	@Override
	public void rollback(Xid tid) throws XAException {
		rollbackResource();
	}

	/**
	 * <p>Start resource.</p>
	 * @param tid Xid
	 * @param flag int
	 * @throws XAException
	 */
	@Override
	public void start(Xid tid, int flag) throws XAException {
		startResource(flag);
	}

	/**
	 * <p>Get text describing this transaction status.</p>
	 * @param status int Value from javax.transaction.Status
	 * <table summary="Transaction status text for int code">
	 * <tr><th>Status Code</th><th>Text</th></tr>
	 * <tr><td>STATUS_NO_TRANSACTION</td><td>no transaction</td></tr>
	 * <tr><td>STATUS_ACTIVE</td><td>active</td></tr>
	 * <tr><td>STATUS_PREPARING</td><td>preparing</td></tr>
	 * <tr><td>STATUS_PREPARED</td><td>prepared</td></tr>
	 * <tr><td>STATUS_COMMITTING</td><td>committing</td></tr>
	 * <tr><td>STATUS_COMMITTED</td><td>committed</td></tr>
	 * <tr><td>STATUS_MARKED_ROLLBACK</td><td>marked rollback</td></tr>
	 * <tr><td>STATUS_ROLLEDBACK</td><td>rolledback</td></tr>
	 * <tr><td>STATUS_ROLLING_BACK</td><td>rolling back</td></tr>
	 * </table>
	 * @return String
	 */
	public static String getStatusAsString(final int status) {
		switch (status) {
		case STATUS_NO_TRANSACTION:
			return "no transaction";
		case STATUS_ACTIVE:
			return "active";
		case STATUS_PREPARING:
			return "preparing";
		case STATUS_PREPARED:
			return "prepared";
		case STATUS_COMMITTING:
			return "committing";
		case STATUS_COMMITTED:
			return "commited";
		case STATUS_MARKED_ROLLBACK:
			return "marked rollback";
		case STATUS_ROLLEDBACK:
			return "rolledback";
		case STATUS_ROLLING_BACK:
			return "rolling back";
		default:
			return "unknown";
		}
	}

	@Override
	public boolean equals(Object other) {
		return other instanceof TransactionalResource && getId().equals(((TransactionalResource) other).getId());
	}

	@Override
	public int hashCode() {
		return getId().hashCode();
	}

	private static class TransactionalResourcesMap {

		private final Map<Xid,LinkedList<TransactionalResource>> m;
		final Object mutex;

		TransactionalResourcesMap() {
			m = new HashMap<>();
			mutex = this;
		}

		public int size() {
			synchronized (mutex) {return m.size();}
		}
		public boolean isEmpty() {
			synchronized (mutex) {return m.isEmpty();}
		}
		public boolean containsKey(Xid key) {
			synchronized (mutex) {return m.containsKey(key);}
		}
		public LinkedList<TransactionalResource> get(Xid key) {
			synchronized (mutex) {return m.get(key);}
		}

		public void put(Xid key, LinkedList<TransactionalResource> resourceList) {
			synchronized (mutex) { m.put(key, resourceList);}
		}

		public void remove(Xid key) {
			synchronized (mutex) { m.remove(key); }
		}

		public void clear() {
			synchronized (mutex) {m.clear();}
		}


		public Set<Map.Entry<Xid,LinkedList<TransactionalResource>>> entrySet() {
			synchronized (mutex) {
				return new HashSet<>(m.entrySet());
			}
		}

	}
}
